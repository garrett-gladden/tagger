<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Teams Room Dashboard</title>

  <!-- React, ReactDOM, Recharts (UMD), Babel for in-browser JSX -->
  <script src="https://unpkg.com/react/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/recharts/umd/Recharts.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <style>
    /* Minimal styling so layout is readable without Tailwind */
    body { margin: 0; font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background:#0A0E1A; color:#E2E8F0; }
    .container { padding: 24px; max-width:1200px; margin:0 auto; }
    .card { background:#151B2D; border-radius:8px; padding:16px; margin-bottom:16px; }
    .grid { display:grid; gap:16px; }
    @media(min-width: 1024px) { .grid.cols-2 { grid-template-columns: 1fr 1fr; } .grid.cols-4 { grid-template-columns: repeat(4, 1fr); } }
    select, button { background:transparent; color:inherit; border:1px solid #2D3748; padding:8px; border-radius:6px; }
    table { width:100%; border-collapse:collapse; color:inherit; }
    th, td { padding:8px; text-align:left; border-bottom:1px solid #2D3748; font-size:13px; }
  </style>
</head>
<body>
  <div id="root" class="container"></div>

  <script type="text/babel">
    const { useState, useMemo } = React;
    const {
      BarChart, Bar, LineChart, Line, ScatterChart, Scatter, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer, Cell, PieChart, Pie
    } = Recharts;

    // Small inline icon components (SVG)
    const Monitor = ({ size = 20 }) => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="#00A3E0" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round">
        <rect x="2" y="3" width="20" height="14" rx="2"></rect>
        <line x1="8" y1="21" x2="16" y2="21"></line>
        <line x1="12" y1="17" x2="12" y2="21"></line>
      </svg>
    );
    const AlertCircle = ({ size = 20 }) => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="#FF4757" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round">
        <circle cx="12" cy="12" r="10"></circle>
        <line x1="12" y1="8" x2="12" y2="12"></line>
        <circle cx="12" cy="16" r="1"></circle>
      </svg>
    );
    const TrendingUp = ({ size = 16 }) => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="#00C781" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round">
        <polyline points="3 17 9 11 13 15 21 7"></polyline>
        <polyline points="21 7 21 13 15 13"></polyline>
      </svg>
    );
    const TrendingDown = ({ size = 16 }) => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="#FF4757" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round">
        <polyline points="21 7 15 13 11 9 3 17"></polyline>
        <polyline points="3 17 3 11 9 11"></polyline>
      </svg>
    );
    const MapPin = ({ size = 18 }) => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="#00A3E0" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round">
        <path d="M21 10c0 7-9 13-9 13S3 17 3 10a9 9 0 1 1 18 0z"></path>
        <circle cx="12" cy="10" r="3"></circle>
      </svg>
    );

    const colors = {
      primary: '#00A3E0',
      success: '#00C781',
      danger: '#FF4757',
      warning: '#FFB020',
      bg: '#0A0E1A',
      bgCard: '#151B2D',
      border: '#2D3748',
      text: '#E2E8F0',
      textMuted: '#94A3B8'
    };

    // generateMockData (same as your version)
    const generateMockData = () => {
      const countries = ['USA', 'UK', 'Germany', 'France', 'Australia', 'Canada', 'Japan', 'Singapore'];
      const cities = {
        'USA': ['New York', 'San Francisco', 'Chicago', 'Austin', 'Seattle'],
        'UK': ['London', 'Manchester', 'Edinburgh'],
        'Germany': ['Berlin', 'Munich', 'Frankfurt'],
        'France': ['Paris', 'Lyon', 'Marseille'],
        'Australia': ['Sydney', 'Melbourne', 'Brisbane'],
        'Canada': ['Toronto', 'Vancouver', 'Montreal'],
        'Japan': ['Tokyo', 'Osaka', 'Nagoya'],
        'Singapore': ['Singapore']
      };
      const manufacturers = ['Microsoft', 'Logitech', 'Poly', 'Crestron', 'Yealink'];
      const deviceTypes = ['Teams Room Standard', 'Teams Room Premium', 'Teams Display', 'Teams Phone'];
      const buildings = ['HQ Building A', 'HQ Building B', 'Remote Office', 'Branch Office', 'Data Center'];
      
      const data = [];
      let deviceId = 1000;
      
      countries.forEach(country => {
        cities[country].forEach(city => {
          const numDevices = Math.floor(Math.random() * 15) + 5;
          for (let i = 0; i < numDevices; i++) {
            const manufacturer = manufacturers[Math.floor(Math.random() * manufacturers.length)];
            const deviceType = deviceTypes[Math.floor(Math.random() * deviceTypes.length)];
            const building = buildings[Math.floor(Math.random() * buildings.length)];
            const subnet = `10.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}.0/24`;
            
            const baseQuality = 75 + Math.random() * 20;
            const manufacturerBonus = manufacturer === 'Microsoft' ? 5 : manufacturer === 'Poly' ? 3 : 0;
            const deviceTypeBonus = deviceType.includes('Premium') ? 5 : 0;
            
            const qualityScore = Math.min(100, baseQuality + manufacturerBonus + deviceTypeBonus + (Math.random() - 0.5) * 10);
            const poorCallPct = Math.max(0, 100 - qualityScore + (Math.random() - 0.5) * 10);
            const avgLatency = 20 + (100 - qualityScore) * 0.5 + Math.random() * 15;
            const packetLoss = Math.max(0, (100 - qualityScore) * 0.05 + Math.random() * 2);
            
            data.push({
              deviceId: `DEV-${deviceId++}`,
              country,
              city,
              building,
              manufacturer,
              deviceType,
              subnet,
              qualityScore: Math.round(qualityScore * 10) / 10,
              poorCallPct: Math.round(poorCallPct * 10) / 10,
              avgLatency: Math.round(avgLatency * 10) / 10,
              packetLoss: Math.round(packetLoss * 100) / 100,
              totalCalls: Math.floor(Math.random() * 500) + 100,
              activeUsers: Math.floor(Math.random() * 50) + 10
            });
          }
        });
      });
      
      return data;
    };

    const generateTimeSeriesData = () => {
      const days = 30;
      const data = [];
      for (let i = days; i >= 0; i--) {
        const date = new Date();
        date.setDate(date.getDate() - i);
        data.push({
          date: date.toISOString().split('T')[0],
          qualityScore: 82 + Math.random() * 10 - (i > 20 ? 5 : 0),
          poorCallPct: 8 + Math.random() * 5 + (i > 20 ? 3 : 0),
          avgLatency: 35 + Math.random() * 15,
          packetLoss: 0.5 + Math.random() * 1.5
        });
      }
      return data;
    };

    function Dashboard() {
      const [devices] = useState(generateMockData());
      const [selectedView, setSelectedView] = useState('overview');
      const [filters, setFilters] = useState({
        country: 'All',
        city: 'All',
        manufacturer: 'All',
        deviceType: 'All',
        subnet: 'All'
      });

      const filterOptions = useMemo(() => ({
        countries: ['All', ...new Set(devices.map(d => d.country))],
        cities: ['All', ...new Set(devices.filter(d => filters.country === 'All' || d.country === filters.country).map(d => d.city))],
        manufacturers: ['All', ...new Set(devices.map(d => d.manufacturer))],
        deviceTypes: ['All', ...new Set(devices.map(d => d.deviceType))],
        subnets: ['All', ...new Set(devices.map(d => d.subnet))]
      }), [devices, filters.country]);

      const filteredDevices = useMemo(() => devices.filter(device => {
        if (filters.country !== 'All' && device.country !== filters.country) return false;
        if (filters.city !== 'All' && device.city !== filters.city) return false;
        if (filters.manufacturer !== 'All' && device.manufacturer !== filters.manufacturer) return false;
        if (filters.deviceType !== 'All' && device.deviceType !== filters.deviceType) return false;
        if (filters.subnet !== 'All' && device.subnet !== filters.subnet) return false;
        return true;
      }), [devices, filters]);

      const metrics = useMemo(() => {
        const avgQuality = filteredDevices.reduce((sum, d) => sum + d.qualityScore, 0) / filteredDevices.length || 0;
        const avgPoorCall = filteredDevices.reduce((sum, d) => sum + d.poorCallPct, 0) / filteredDevices.length || 0;
        const totalCalls = filteredDevices.reduce((sum, d) => sum + d.totalCalls, 0);
        const devicesWithIssues = filteredDevices.filter(d => d.qualityScore < 80).length;
        
        return {
          avgQuality: Math.round(avgQuality * 10) / 10,
          avgPoorCall: Math.round(avgPoorCall * 10) / 10,
          totalDevices: filteredDevices.length,
          totalCalls,
          devicesWithIssues
        };
      }, [filteredDevices]);

      const dataByManufacturer = useMemo(() => {
        const grouped = {};
        filteredDevices.forEach(device => {
          if (!grouped[device.manufacturer]) {
            grouped[device.manufacturer] = { manufacturer: device.manufacturer, devices: 0, sumQuality: 0, sumPoorCall: 0 };
          }
          grouped[device.manufacturer].devices++;
          grouped[device.manufacturer].sumQuality += device.qualityScore;
          grouped[device.manufacturer].sumPoorCall += device.poorCallPct;
        });
        return Object.values(grouped).map(g => ({
          ...g,
          avgQuality: Math.round((g.sumQuality / g.devices) * 10) / 10,
          poorCallPct: Math.round((g.sumPoorCall / g.devices) * 10) / 10
        }));
      }, [filteredDevices]);

      const dataByDeviceType = useMemo(() => {
        const grouped = {};
        filteredDevices.forEach(device => {
          if (!grouped[device.deviceType]) {
            grouped[device.deviceType] = { deviceType: device.deviceType, count: 0, sumQuality: 0 };
          }
          grouped[device.deviceType].count++;
          grouped[device.deviceType].sumQuality += device.qualityScore;
        });
        return Object.values(grouped).map(g => ({ ...g, avgQuality: Math.round((g.sumQuality / g.count) * 10) / 10, count: g.count }));
      }, [filteredDevices]);

      const dataByCountry = useMemo(() => {
        const grouped = {};
        filteredDevices.forEach(device => {
          if (!grouped[device.country]) grouped[device.country] = { country: device.country, totalDevices: 0, sumQuality: 0 };
          grouped[device.country].totalDevices++;
          grouped[device.country].sumQuality += device.qualityScore;
        });
        return Object.values(grouped).map(g => ({ ...g, avgQuality: Math.round((g.sumQuality / g.totalDevices) * 10) / 10 })).sort((a,b)=>b.avgQuality-a.avgQuality);
      }, [filteredDevices]);

      const outliers = useMemo(() => {
        const avg = metrics.avgQuality;
        const stdDev = Math.sqrt(filteredDevices.reduce((sum, d) => sum + Math.pow(d.qualityScore - avg, 2), 0) / Math.max(1, filteredDevices.length));
        return filteredDevices.filter(d => d.qualityScore < avg - 1.5 * stdDev).sort((a,b)=>a.qualityScore-b.qualityScore).slice(0,10);
      }, [filteredDevices, metrics.avgQuality]);

      const timeSeriesData = useMemo(() => generateTimeSeriesData(filters), [filters]);

      return (
        <div>
          <div style={{marginBottom:12}}>
            <h1 style={{margin:0}}>Teams Room Device Performance</h1>
            <p style={{margin:4, color:colors.textMuted}}>Real-time monitoring and analytics across your global deployment</p>
          </div>

          <div className="card" style={{marginBottom:12}}>
            <div style={{display:'flex', gap:8, flexWrap:'wrap'}}>
              <select value={filters.country} onChange={(e)=>setFilters({...filters,country:e.target.value, city:'All'})}>
                {filterOptions.countries.map(c=> <option key={c} value={c}>{c}</option>)}
              </select>
              <select value={filters.city} onChange={(e)=>setFilters({...filters,city:e.target.value})}>
                {filterOptions.cities.map(c=> <option key={c} value={c}>{c}</option>)}
              </select>
              <select value={filters.manufacturer} onChange={(e)=>setFilters({...filters,manufacturer:e.target.value})}>
                {filterOptions.manufacturers.map(m=> <option key={m} value={m}>{m}</option>)}
              </select>
              <select value={filters.deviceType} onChange={(e)=>setFilters({...filters,deviceType:e.target.value})}>
                {filterOptions.deviceTypes.map(t=> <option key={t} value={t}>{t}</option>)}
              </select>
            </div>
          </div>

          <div className="grid cols-4" style={{marginBottom:12}}>
            <div className="card">
              <div style={{display:'flex',justifyContent:'space-between',alignItems:'center'}}>
                <div>
                  <div style={{fontSize:12,color:colors.textMuted}}>Average Quality Score</div>
                  <div style={{fontSize:22,fontWeight:700}}>{metrics.avgQuality}</div>
                  <div style={{fontSize:12,color:colors.textMuted}}>Across {metrics.totalDevices} devices</div>
                </div>
                <Monitor />
              </div>
            </div>
            <div className="card">
              <div style={{display:'flex',justifyContent:'space-between',alignItems:'center'}}>
                <div>
                  <div style={{fontSize:12,color:colors.textMuted}}>Poor Call Percentage</div>
                  <div style={{fontSize:22,fontWeight:700}}>{metrics.avgPoorCall}%</div>
                  <div style={{fontSize:12,color:colors.textMuted}}>Of {metrics.totalCalls.toLocaleString()} total calls</div>
                </div>
                <AlertCircle />
              </div>
            </div>
            <div className="card">
              <div>
                <div style={{fontSize:12,color:colors.textMuted}}>Devices with Issues</div>
                <div style={{fontSize:22,fontWeight:700}}>{metrics.devicesWithIssues}</div>
                <div style={{fontSize:12,color:colors.textMuted}}>Quality score &lt; 80</div>
              </div>
            </div>
            <div className="card">
              <div>
                <div style={{fontSize:12,color:colors.textMuted}}>Geographic Coverage</div>
                <div style={{fontSize:22,fontWeight:700}}>{filterOptions.countries.length - 1}</div>
                <div style={{fontSize:12,color:colors.textMuted}}>{filterOptions.cities.length - 1} cities monitored</div>
              </div>
            </div>
          </div>

          {/* Simple overview charts (Recharts) */}
          <div className="grid cols-2">
            <div className="card">
              <h3>Performance by Manufacturer</h3>
              <ResponsiveContainer width="100%" height={240}>
                <BarChart data={dataByManufacturer}>
                  <CartesianGrid strokeDasharray="3 3" stroke={colors.border} />
                  <XAxis dataKey="manufacturer" stroke={colors.textMuted} />
                  <YAxis stroke={colors.textMuted} />
                  <Tooltip contentStyle={{ backgroundColor: colors.bgCard, border: `1px solid ${colors.border}` }} />
                  <Legend />
                  <Bar dataKey="avgQuality" fill={colors.primary} name="Avg Quality Score" />
                </BarChart>
              </ResponsiveContainer>
            </div>

            <div className="card">
              <h3>Device Distribution</h3>
              <ResponsiveContainer width="100%" height={240}>
                <PieChart>
                  <Pie data={dataByDeviceType} dataKey="count" nameKey="deviceType" cx="50%" cy="50%" outerRadius={80} label>
                    {dataByDeviceType.map((entry, index) => (
                      <Cell key={`cell-${index}`} fill={[colors.primary, colors.warning, colors.success, '#9B59B6'][index % 4]} />
                    ))}
                  </Pie>
                  <Tooltip contentStyle={{ backgroundColor: colors.bgCard, border: `1px solid ${colors.border}` }} />
                </PieChart>
              </ResponsiveContainer>
            </div>
          </div>

          {/* Outliers table */}
          <div className="card">
            <h3 style={{marginTop:0}}>Devices Requiring Attention</h3>
            <p style={{marginTop:6, color:colors.textMuted}}>Devices with quality scores &lt; 1.5 std dev below avg ({metrics.avgQuality})</p>
            <div style={{overflowX:'auto', marginTop:8}}>
              <table>
                <thead>
                  <tr>
                    <th>Device ID</th>
                    <th>Location</th>
                    <th>Manufacturer</th>
                    <th>Type</th>
                    <th style={{textAlign:'right'}}>Quality</th>
                    <th style={{textAlign:'right'}}>Poor Call %</th>
                    <th>Subnet</th>
                  </tr>
                </thead>
                <tbody>
                  {outliers.map((device, idx) => (
                    <tr key={idx}>
                      <td>{device.deviceId}</td>
                      <td>{device.city}, {device.country}</td>
                      <td>{device.manufacturer}</td>
                      <td>{device.deviceType}</td>
                      <td style={{textAlign:'right'}}>{device.qualityScore}</td>
                      <td style={{textAlign:'right'}}>{device.poorCallPct}%</td>
                      <td style={{fontFamily:'monospace', fontSize:12}}>{device.subnet}</td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          </div>

        </div>
      );
    } // end Dashboard

    // render (supports React 18+ and older)
    const rootEl = document.getElementById('root');
    if (ReactDOM.createRoot) {
      ReactDOM.createRoot(rootEl).render(<Dashboard />);
    } else {
      ReactDOM.render(<Dashboard />, rootEl);
    }
  </script>
</body>
</html>